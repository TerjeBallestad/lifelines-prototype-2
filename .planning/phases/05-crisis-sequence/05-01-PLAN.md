---
phase: 05-crisis-sequence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/game.ts
  - src/stores/CrisisStore.ts
  - src/stores/RootStore.ts
  - src/data/crisis.ts
autonomous: true

must_haves:
  truths:
    - "CrisisStore tracks crisis state (inactive, warning, active, resolved)"
    - "Crisis actions are defined with skill requirements"
    - "Action attempts are tracked for retry penalty calculation"
  artifacts:
    - path: "src/stores/CrisisStore.ts"
      provides: "Crisis state machine and action tracking"
      exports: ["CrisisStore"]
    - path: "src/data/crisis.ts"
      provides: "Crisis action definitions and epilogue text"
      exports: ["CRISIS_ACTIONS", "EPILOGUE_TEXT"]
    - path: "src/types/game.ts"
      provides: "CrisisAction and CrisisState types"
      contains: "CrisisAction"
  key_links:
    - from: "src/stores/RootStore.ts"
      to: "src/stores/CrisisStore.ts"
      via: "store instantiation"
      pattern: "crisisStore.*CrisisStore"
---

<objective>
Create the CrisisStore and crisis data foundation for the Day 10 crisis sequence.

Purpose: Establish the state management layer that will track crisis progression, action attempts, and outcomes. This follows the established QuestStore pattern.

Output: CrisisStore with state machine, crisis action definitions, and types.
</objective>

<execution_context>
@/Users/godstemning/.claude/get-shit-done/workflows/execute-plan.md
@/Users/godstemning/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-crisis-sequence/05-CONTEXT.md
@.planning/phases/05-crisis-sequence/05-RESEARCH.md

@src/stores/QuestStore.ts (pattern reference)
@src/stores/RootStore.ts
@src/types/game.ts
@src/systems/SkillSystem.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define Crisis Types</name>
  <files>src/types/game.ts</files>
  <action>
Add crisis-related types at the end of game.ts:

```typescript
// Crisis system types
export type CrisisState = 'inactive' | 'warning' | 'active' | 'resolved';
export type CrisisOutcome = 'saved' | 'lost' | null;

export interface CrisisAction {
  id: string;
  name: string;
  icon: string;  // Emoji
  description: string;
  skillCategory: SkillCategory;
  baseDifficulty: number;  // 1-3
  // Non-phone actions give hope bonus to next phone attempt
  givesHopeBonus?: boolean;
}

export interface CrisisActionResult {
  action: CrisisAction;
  succeeded: boolean;
  roll: number;
  chance: number;
}
```

Keep existing types unchanged. These types follow the established Activity and Quest patterns.
  </action>
  <verify>TypeScript compiles: `npm run build` passes without type errors</verify>
  <done>CrisisAction and CrisisState types are exported from game.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create Crisis Data</name>
  <files>src/data/crisis.ts</files>
  <action>
Create new file `src/data/crisis.ts` with crisis action definitions and epilogue text:

```typescript
import type { CrisisAction } from '../types/game';

/**
 * Actions available during the crisis
 * Phone is the critical action - success saves Mother
 * Other actions give hope bonus (+10% to next phone attempt)
 */
export const CRISIS_ACTIONS: CrisisAction[] = [
  {
    id: 'call-emergency',
    name: 'Call Emergency Services',
    icon: 'ðŸ“ž',
    description: 'Dial 113 and explain the situation',
    skillCategory: 'Social',  // Phone skill is Social category
    baseDifficulty: 2,
  },
  {
    id: 'help-mother',
    name: 'Help Mother',
    icon: 'ðŸ¤²',
    description: 'Try to make her comfortable',
    skillCategory: 'Practical',
    baseDifficulty: 1,
    givesHopeBonus: true,
  },
  {
    id: 'run-neighbor',
    name: 'Run to Neighbor',
    icon: 'ðŸƒ',
    description: 'Get help from next door',
    skillCategory: 'Social',
    baseDifficulty: 1,
    givesHopeBonus: true,
  },
];

/**
 * Epilogue text for each outcome
 */
export const EPILOGUE_TEXT = {
  saved: {
    title: 'Mother Saved',
    paragraphs: [
      'The ambulance arrived in time. Mother was rushed to the hospital, where doctors stabilized her condition.',
      'Elling sat in the waiting room, hands still trembling from the phone call. It had taken everything he had to dial those numbers, to speak to the stranger on the other end.',
      'But he had done it. When it mattered most, he had found the courage to act.',
      'Mother would need time to recover, and things would be different now. But they would face it together.',
    ],
  },
  lost: {
    title: 'Mother Lost',
    paragraphs: [
      'By the time help arrived, it was too late. Mother had slipped away quietly, lying on the floor where she had fallen.',
      'Elling sat beside her, frozen. He had tried to call, but his hands wouldn\'t stop shaking. The numbers blurred together. His voice wouldn\'t come.',
      'The phone skill he had neglected, the calls he had avoided - they had mattered more than he ever knew.',
      'Now he was alone, in the apartment that had been their whole world. And he would have to learn to survive in a world that had always terrified him.',
    ],
  },
};
```

The "Social" skill category is used for phone calls per the color->skill mapping (Red->Social, but phone requires communication skills trained through social activities).
  </action>
  <verify>File exists and exports are importable: add temporary import in another file or check with `grep -l "CRISIS_ACTIONS" src/data/`</verify>
  <done>CRISIS_ACTIONS array with 3 actions and EPILOGUE_TEXT with both endings are defined</done>
</task>

<task type="auto">
  <name>Task 3: Create CrisisStore</name>
  <files>src/stores/CrisisStore.ts, src/stores/RootStore.ts</files>
  <action>
Create `src/stores/CrisisStore.ts` following QuestStore pattern:

```typescript
import { makeAutoObservable } from 'mobx';
import type { CrisisState, CrisisOutcome, CrisisAction, CrisisActionResult } from '../types/game';
import { CRISIS_ACTIONS } from '../data/crisis';
import { calculateSuccessChance } from '../systems/SkillSystem';
import type { RootStore } from './RootStore';

/**
 * CrisisStore manages the Day 10 crisis sequence
 *
 * State machine: inactive -> warning -> active -> resolved
 * - inactive: Normal gameplay, day < 10 or hour < 8
 * - warning: Day 10, hours 8-13, Mother shows warning signs
 * - active: Day 10, hour >= 14, crisis modal visible
 * - resolved: Outcome determined, showing epilogue
 *
 * Key features:
 * - Tracks action attempts for retry penalty
 * - Accumulates hope bonus from non-phone actions
 * - Determines outcome based on phone call success
 */
export class CrisisStore {
  crisisState: CrisisState = 'inactive';
  outcome: CrisisOutcome = null;

  // Track attempts per action for retry penalty (-15% per attempt)
  actionAttempts: Map<string, number> = new Map();

  // Hope bonus from helping actions (+10% each, max +20%)
  hopeBonus: number = 0;

  // Last action result for UI display
  lastActionResult: CrisisActionResult | null = null;

  readonly rootStore: RootStore;

  constructor(rootStore: RootStore) {
    this.rootStore = rootStore;
    makeAutoObservable(this, { rootStore: false });
  }

  /**
   * Should crisis enter warning phase?
   * Day 10, hour >= 8, currently inactive
   */
  get shouldStartWarning(): boolean {
    const { day, hour } = this.rootStore.timeStore;
    return day === 10 && hour >= 8 && this.crisisState === 'inactive';
  }

  /**
   * Should crisis become active?
   * Day 10, hour >= 14, currently in warning
   */
  get shouldTrigger(): boolean {
    const { day, hour } = this.rootStore.timeStore;
    return day === 10 && hour >= 14 && this.crisisState === 'warning';
  }

  /**
   * Available crisis actions
   */
  get actions(): CrisisAction[] {
    return CRISIS_ACTIONS;
  }

  /**
   * Get success chance for an action
   * Base: calculateSuccessChance(skillLevel, difficulty)
   * Modifiers: -15% per retry, +hopeBonus, -shadowPenalty
   */
  getActionSuccessChance(actionId: string): number {
    const action = CRISIS_ACTIONS.find(a => a.id === actionId);
    if (!action) return 0;

    // Get Elling's skill level
    const skill = this.rootStore.skillStore.getSkill('elling', action.skillCategory);
    const skillLevel = skill?.level ?? 1;

    // Base chance from skill system
    let chance = calculateSuccessChance(skillLevel, action.baseDifficulty);

    // Retry penalty: -15% per previous attempt
    const attempts = this.actionAttempts.get(actionId) ?? 0;
    chance -= attempts * 15;

    // Hope bonus from helping actions (phone only benefits)
    if (actionId === 'call-emergency') {
      chance += this.hopeBonus;
    }

    // Shadow state penalty
    const elling = this.rootStore.characterStore.getCharacter('elling');
    if (elling && this.getEllingInShadowState()) {
      chance -= 20;
    }

    // Clamp to valid range
    return Math.max(5, Math.min(95, chance));
  }

  /**
   * Check if Elling is in shadow state during crisis
   * Blue shadow = paralysis when overskudd < 30 during active crisis
   */
  getEllingInShadowState(): boolean {
    const elling = this.rootStore.characterStore.getCharacter('elling');
    if (!elling) return false;

    return this.crisisState === 'active' && elling.overskudd < 30;
  }

  /**
   * Enter warning phase (Day 10 morning)
   */
  startWarning(): void {
    if (this.crisisState === 'inactive') {
      this.crisisState = 'warning';
    }
  }

  /**
   * Trigger active crisis (Mother collapses)
   */
  triggerCrisis(): void {
    if (this.crisisState === 'warning') {
      this.crisisState = 'active';
      this.rootStore.timeStore.pause();
    }
  }

  /**
   * Attempt a crisis action
   * Returns result and updates state
   */
  attemptAction(actionId: string): CrisisActionResult | null {
    const action = CRISIS_ACTIONS.find(a => a.id === actionId);
    if (!action || this.crisisState !== 'active') return null;

    const chance = this.getActionSuccessChance(actionId);
    const roll = Math.random() * 100;
    const succeeded = roll < chance;

    // Track attempt
    const attempts = this.actionAttempts.get(actionId) ?? 0;
    this.actionAttempts.set(actionId, attempts + 1);

    // Apply hope bonus if this action gives it
    if (action.givesHopeBonus && succeeded) {
      this.hopeBonus = Math.min(20, this.hopeBonus + 10);
    }

    const result: CrisisActionResult = {
      action,
      succeeded,
      roll,
      chance,
    };

    this.lastActionResult = result;

    // Check for resolution
    if (actionId === 'call-emergency' && succeeded) {
      this.resolveWith('saved');
    }

    return result;
  }

  /**
   * Clear last action result (after UI displays it)
   */
  clearLastActionResult(): void {
    this.lastActionResult = null;
  }

  /**
   * Resolve crisis with outcome
   */
  resolveWith(outcome: CrisisOutcome): void {
    this.outcome = outcome;
    this.crisisState = 'resolved';
  }

  /**
   * Give up (player chooses to accept loss)
   */
  giveUp(): void {
    this.resolveWith('lost');
  }

  /**
   * Reset for new game
   */
  reset(): void {
    this.crisisState = 'inactive';
    this.outcome = null;
    this.actionAttempts.clear();
    this.hopeBonus = 0;
    this.lastActionResult = null;
  }
}
```

Then update `src/stores/RootStore.ts`:

1. Add import: `import { CrisisStore } from './CrisisStore';`
2. Add property: `crisisStore: CrisisStore;`
3. Add to constructor after questStore: `this.crisisStore = new CrisisStore(this);`
  </action>
  <verify>
- `npm run build` passes
- CrisisStore is accessible via useGameStore()
  </verify>
  <done>
- CrisisStore tracks crisis state machine (inactive -> warning -> active -> resolved)
- Action attempts tracked in Map for retry penalty
- Hope bonus accumulates from helper actions
- RootStore creates and exposes crisisStore
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. `npm run dev` starts without runtime errors
3. Types are properly exported: `grep "CrisisAction" src/types/game.ts`
4. Store is wired: `grep "crisisStore" src/stores/RootStore.ts`
</verification>

<success_criteria>
- CrisisStore exists with state machine and action tracking
- Crisis types (CrisisAction, CrisisState, CrisisOutcome) defined in game.ts
- Crisis data (actions, epilogue) defined in crisis.ts
- RootStore creates crisisStore
- Build passes with no type errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-crisis-sequence/05-01-SUMMARY.md`
</output>
